class Solution {
private:
    TreeNode* Build(
        vector<int>& preorder, 
        vector<int>& inorder,
        int preStart,int preEnd,
        int inStart,int inEnd,
        unordered_map<int,int>& inMap){
            if(preStart>preEnd||inStart>inEnd){
                return nullptr;
            }
        int rootVal=preorder[preStart];
        TreeNode* root=new TreeNode(rootVal);
        int inRootIdx=inMap[rootVal];
        int leftSize=inRootIdx-inStart;
        root->left=Build(
            preorder,inorder,
            preStart+1,preStart+leftSize,
            inStart,inRootIdx-1,
            inMap
        );
        root->right=Build(
            preorder,inorder,
            preStart+leftSize+1,preEnd,
            inRootIdx+1,inEnd,
            inMap);
        return root;
        }
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.empty()) return nullptr;
        unordered_map<int,int> inMap;
        for(int i=0;i<inorder.size();i++){
            inMap[inorder[i]]=i;
        }
        int length=preorder.size();
        TreeNode* root=Build(preorder,inorder,0,length-1,0,length-1,inMap);
        return root;
    }
};
